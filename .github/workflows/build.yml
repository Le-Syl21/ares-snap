# =============================================================================
# Ares Snap Builder - Automated Snap packaging for Ares emulator
# Constructeur Snap Ares - Packaging Snap automatisÃ© pour l'Ã©mulateur Ares
# =============================================================================
#
# This workflow automatically builds and publishes Snap packages whenever
# a new version of Ares is released. Builds natively for amd64 and arm64.
#
# Ce workflow construit et publie automatiquement des paquets Snap Ã  chaque
# nouvelle version d'Ares. Build natif pour amd64 et arm64.
#
# =============================================================================
# EDUCATIONAL PURPOSE / BUT PÃ‰DAGOGIQUE
# =============================================================================
# This repository is designed as a learning resource for packaging any
# application as a Snap. Every section is commented to explain not just
# WHAT it does, but WHY it's configured that way.
#
# Ce dÃ©pÃ´t est conÃ§u comme ressource pÃ©dagogique pour packager n'importe
# quelle application en Snap. Chaque section est commentÃ©e pour expliquer
# non seulement CE QUE Ã§a fait, mais POURQUOI c'est configurÃ© ainsi.
#
# =============================================================================
# REQUIRED SETUP / CONFIGURATION REQUISE
# =============================================================================
# Before this workflow can run, you need to configure:
# Avant que ce workflow puisse s'exÃ©cuter, vous devez configurer :
#
# 1. TRACKING FILE / FICHIER DE SUIVI
#    Create .last_built_tags.json at repo root with initial content:
#    CrÃ©er .last_built_tags.json Ã  la racine du dÃ©pÃ´t avec le contenu initial :
#      {"amd64": "", "arm64": ""}
#
#    WHY A FILE INSTEAD OF REPOSITORY VARIABLES? / POURQUOI UN FICHIER ?
#    GitHub's GITHUB_TOKEN cannot write repository variables (403 error).
#    A committed file works with the standard GITHUB_TOKEN and contents: write.
#    No PAT needed! / Pas besoin de PAT !
#
#    Le GITHUB_TOKEN de GitHub ne peut pas Ã©crire les variables de dÃ©pÃ´t (erreur 403).
#    Un fichier committÃ© fonctionne avec le GITHUB_TOKEN standard et contents: write.
#
# 2. REPOSITORY SECRET (Settings > Secrets and variables > Actions > Secrets)
#    SECRET DE DÃ‰PÃ”T
#    - SNAPCRAFT_TOKEN : Authentication token for Snap Store publishing
#                        Token d'authentification pour publier sur le Snap Store
#      HOW TO GET IT / COMMENT L'OBTENIR :
#        $ sudo snap install snapcraft --classic
#        $ snapcraft login
#        $ snapcraft export-login snapcraft.login
#        $ cat snapcraft.login  # Copy this content to GitHub secret
#        $ rm snapcraft.login   # Delete for security
#
# 3. REPOSITORY PERMISSIONS (Settings > Actions > General > Workflow permissions)
#    PERMISSIONS DU DÃ‰PÃ”T
#    - Select "Read and write permissions"
#      SÃ©lectionner "Read and write permissions"
# =============================================================================

name: Build Ares Snap

# -----------------------------------------------------------------------------
# TRIGGERS / DÃ‰CLENCHEURS
# -----------------------------------------------------------------------------
on:
  # SCHEDULED TRIGGER / DÃ‰CLENCHEUR PLANIFIÃ‰
  # Cron syntax: minute hour day-of-month month day-of-week
  #
  # WHY 6:00 UTC? / POURQUOI 6H UTC ?
  # Most releases happen during US/EU business hours, so checking in the
  # morning UTC catches overnight releases without running too frequently.
  schedule:
    - cron: '0 6 * * *'

  # MANUAL TRIGGER / DÃ‰CLENCHEUR MANUEL
  workflow_dispatch:
    inputs:
      force_build:
        description: 'Force build (bypass version check) / Forcer le build'
        required: false
        default: false
        type: boolean

# -----------------------------------------------------------------------------
# PERMISSIONS
# -----------------------------------------------------------------------------
# contents: write is needed to commit the updated tracking file.
# contents: write est nÃ©cessaire pour committer le fichier de suivi mis Ã  jour.
#
# SECURITY TIP / CONSEIL SÃ‰CURITÃ‰ :
# Always use minimum required permissions (principle of least privilege).
# Toujours utiliser le minimum de permissions nÃ©cessaires (principe du moindre privilÃ¨ge).
# -----------------------------------------------------------------------------
permissions:
  contents: write

# -----------------------------------------------------------------------------
# JOBS OVERVIEW / VUE D'ENSEMBLE DES JOBS
# -----------------------------------------------------------------------------
#
#   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
#   â”‚  check   â”‚  Single upstream query + read tracking file
#   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
#        â”‚ outputs: latest_tag, build_amd64, build_arm64
#        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
#   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
#   â”‚  build   â”‚      â”‚  build   â”‚  Matrix strategy: parallel native builds
#   â”‚  amd64   â”‚      â”‚  arm64   â”‚
#   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
#        â”‚                  â”‚
#        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#           â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
#           â”‚ update-tags â”‚  Commit results (only successful arches)
#           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#
# WHY THIS STRUCTURE? / POURQUOI CETTE STRUCTURE ?
# - Single check: upstream is queried once, not twice
#   VÃ©rification unique : l'upstream est interrogÃ© une seule fois
# - Matrix build: less code duplication, same behavior
#   Build en matrice : moins de duplication, mÃªme comportement
# - Separate update job: avoids race conditions between parallel jobs
#   Job de MAJ sÃ©parÃ© : Ã©vite les race conditions entre jobs parallÃ¨les
# - [skip ci] in commit message: prevents the push from re-triggering
#   [skip ci] dans le message de commit : empÃªche le push de re-dÃ©clencher
# -----------------------------------------------------------------------------
jobs:
  # ===========================================================================
  # JOB 1: CHECK FOR NEW RELEASE
  # JOB 1 : VÃ‰RIFIER UNE NOUVELLE RELEASE
  # ===========================================================================
  # Queries upstream once and decides which architectures need building.
  # Interroge l'upstream une seule fois et dÃ©cide quelles architectures builder.
  # ===========================================================================
  check:
    runs-on: ubuntu-latest
    outputs:
      latest_tag: ${{ steps.check.outputs.latest_tag }}
      version: ${{ steps.check.outputs.version }}
      build_amd64: ${{ steps.check.outputs.build_amd64 }}
      build_arm64: ${{ steps.check.outputs.build_arm64 }}

    steps:
      # We need our repo to read .last_built_tags.json
      # On a besoin de notre repo pour lire .last_built_tags.json
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check for new version
        id: check
        run: |
          # Fetch all release tags from upstream (vXXX pattern only)
          # RÃ©cupÃ¨re tous les tags de release depuis l'upstream (pattern vXXX uniquement)
          #
          # Command breakdown / DÃ©composition de la commande :
          #   git ls-remote --tags  : List remote tags without cloning
          #   cut -d/ -f3           : Extract tag name from refs/tags/v123
          #   sort -V               : Version sort (v2 < v10, not alphabetical)
          #   tail -1               : Get the last (highest) version
          LATEST_TAG=$(git ls-remote --tags https://github.com/ares-emulator/ares.git 'refs/tags/v*' \
            | cut -d/ -f3 \
            | sort -V \
            | tail -1)

          # Read tracking file / Lire le fichier de suivi
          # jq -r '.key // ""' : Extract value, default to empty string if missing
          if [ -f .last_built_tags.json ]; then
            LAST_AMD64=$(jq -r '.amd64 // ""' .last_built_tags.json)
            LAST_ARM64=$(jq -r '.arm64 // ""' .last_built_tags.json)
          else
            LAST_AMD64=""
            LAST_ARM64=""
          fi

          echo "=========================================="
          echo "Latest release tag : $LATEST_TAG"
          echo "Last built amd64   : $LAST_AMD64"
          echo "Last built arm64   : $LAST_ARM64"
          echo "=========================================="

          # Decision logic / Logique de dÃ©cision
          if [ "${{ inputs.force_build }}" == "true" ]; then
            echo "âš¡ FORCE BUILD REQUESTED"
            BUILD_AMD64=true
            BUILD_ARM64=true
          else
            [ "$LATEST_TAG" != "$LAST_AMD64" ] && BUILD_AMD64=true || BUILD_AMD64=false
            [ "$LATEST_TAG" != "$LAST_ARM64" ] && BUILD_ARM64=true || BUILD_ARM64=false
          fi

          [ "$BUILD_AMD64" == "true" ] && echo "ğŸ†• amd64: needs build" || echo "âœ“ amd64: up to date"
          [ "$BUILD_ARM64" == "true" ] && echo "ğŸ†• arm64: needs build" || echo "âœ“ arm64: up to date"

          # Export outputs for downstream jobs
          # Exporter les outputs pour les jobs suivants
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "version=${LATEST_TAG#v}" >> $GITHUB_OUTPUT
          echo "build_amd64=$BUILD_AMD64" >> $GITHUB_OUTPUT
          echo "build_arm64=$BUILD_ARM64" >> $GITHUB_OUTPUT

  # ===========================================================================
  # JOB 2: BUILD SNAP PACKAGES (MATRIX)
  # JOB 2 : CONSTRUIRE LES PAQUETS SNAP (MATRICE)
  # ===========================================================================
  # Uses a matrix strategy to avoid duplicating the entire build job.
  # Each architecture runs on its native runner for reliable builds.
  #
  # Utilise une stratÃ©gie matrice pour Ã©viter de dupliquer tout le job de build.
  # Chaque architecture tourne sur son runner natif pour des builds fiables.
  #
  # MATRIX STRATEGY / STRATÃ‰GIE MATRICE :
  # Instead of writing two nearly identical jobs, we define a matrix of
  # parameters and GitHub Actions creates one job instance per combination.
  # The 'include' syntax lets us set custom values per matrix entry.
  #
  # Au lieu d'Ã©crire deux jobs quasi identiques, on dÃ©finit une matrice de
  # paramÃ¨tres et GitHub Actions crÃ©e une instance par combinaison.
  # La syntaxe 'include' permet de dÃ©finir des valeurs custom par entrÃ©e.
  # ===========================================================================
  build:
    needs: check
    strategy:
      # fail-fast: false ensures one arch failing doesn't cancel the other
      # fail-fast: false assure qu'un Ã©chec sur une arch n'annule pas l'autre
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-latest
            should_build: ${{ needs.check.outputs.build_amd64 }}
          - arch: arm64
            runner: ubuntu-24.04-arm
            should_build: ${{ needs.check.outputs.build_arm64 }}

    # CONDITIONAL EXECUTION / EXÃ‰CUTION CONDITIONNELLE
    # Skip the entire job if this arch doesn't need building.
    # This saves runner allocation time (especially for ARM runners).
    if: ${{ matrix.should_build == 'true' }}

    runs-on: ${{ matrix.runner }}

    steps:
      - name: Checkout config
        uses: actions/checkout@v4

      - name: Clone ares source
        run: |
          TAG=${{ needs.check.outputs.latest_tag }}
          VERSION=${{ needs.check.outputs.version }}

          echo "ğŸ“¦ Cloning ares $TAG (${{ matrix.arch }})..."

          # --depth 1 : Shallow clone (only latest commit, saves time/bandwidth)
          # --branch  : Checkout specific tag instead of default branch
          git clone --depth 1 --branch $TAG \
            https://github.com/ares-emulator/ares.git ares-src

          # Overlay our snap configuration / Superposer notre config snap
          cp -r snap/ ares-src/
          cp deps.json ares-src/

          # Inject version / Injecter la version
          sed -i "s/^version: .*/version: '$VERSION'/" ares-src/snap/snapcraft.yaml
          echo "âœ“ Version set to $VERSION"

      # Snapcraft is the tool that builds Snap packages
      # --classic : Allows snapcraft full system access (needed for building)
      - name: Install snapcraft
        run: sudo snap install snapcraft --classic

      # LXD provides clean container environments for snapcraft builds.
      # Snapcraft automatically installs all build-packages and build-snaps inside.
      - name: Setup LXD
        uses: canonical/setup-lxd@main

      - name: Build snap
        id: build
        run: |
          cd ares-src
          snapcraft pack
          echo "snap_file=$(ls *.snap)" >> $GITHUB_OUTPUT

      # ARTIFACTS / ARTEFACTS
      # Preserved after workflow completes. Useful for manual testing
      # or downloading if Snap Store publishing fails.
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ares-${{ needs.check.outputs.latest_tag }}-${{ matrix.arch }}
          path: ares-src/${{ steps.build.outputs.snap_file }}
          retention-days: 30

      # SNAP STORE CHANNELS / CANAUX SNAP STORE :
      #   stable > candidate > beta > edge
      #
      # continue-on-error: if publishing fails (e.g., name not registered),
      # the build artifact is still available for manual upload later.
      - name: Publish to Snap Store
        env:
          SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAPCRAFT_TOKEN }}
        run: |
          echo "ğŸš€ Publishing to Snap Store (${{ matrix.arch }})..."
          snapcraft upload ares-src/${{ steps.build.outputs.snap_file }} --release=stable
        continue-on-error: true

  # ===========================================================================
  # JOB 3: UPDATE TRACKING FILE
  # JOB 3 : METTRE Ã€ JOUR LE FICHIER DE SUIVI
  # ===========================================================================
  # Runs after both builds complete. Updates .last_built_tags.json only for
  # architectures that built successfully, then commits + pushes.
  #
  # Tourne aprÃ¨s la fin des deux builds. Met Ã  jour .last_built_tags.json
  # uniquement pour les architectures qui ont buildÃ© avec succÃ¨s, puis commit + push.
  #
  # WHY A SEPARATE JOB? / POURQUOI UN JOB SÃ‰PARÃ‰ ?
  # If both arches committed from their own job, they'd create a race condition
  # (parallel pushes to the same branch). A single final job avoids this.
  #
  # Si les deux arches committaient depuis leur propre job, Ã§a crÃ©erait une
  # race condition (pushs parallÃ¨les sur la mÃªme branche). Un seul job final Ã©vite Ã§a.
  # ===========================================================================
  update-tags:
    needs: [check, build]

    # always() is required because matrix jobs with 'if' that evaluate to false
    # are reported as skipped, which would skip this job too without always().
    # We only run if at least one build didn't fail.
    #
    # always() est requis car les jobs de matrice avec 'if' Ã©valuÃ© Ã  false sont
    # marquÃ©s comme skippÃ©s, ce qui skipperait aussi ce job sans always().
    if: >-
      always() &&
      (needs.check.outputs.build_amd64 == 'true' || needs.check.outputs.build_arm64 == 'true') &&
      needs.build.result != 'failure'

    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Update tracking file
        run: |
          TAG=${{ needs.check.outputs.latest_tag }}

          # Read current state or initialize
          # Lire l'Ã©tat actuel ou initialiser
          if [ -f .last_built_tags.json ]; then
            JSON=$(cat .last_built_tags.json)
          else
            JSON='{"amd64":"","arm64":""}'
          fi

          # Update only architectures that were requested to build
          # Mettre Ã  jour uniquement les architectures demandÃ©es
          if [ "${{ needs.check.outputs.build_amd64 }}" == "true" ]; then
            JSON=$(echo "$JSON" | jq --arg t "$TAG" '.amd64 = $t')
            echo "âœ… amd64 â†’ $TAG"
          fi
          if [ "${{ needs.check.outputs.build_arm64 }}" == "true" ]; then
            JSON=$(echo "$JSON" | jq --arg t "$TAG" '.arm64 = $t')
            echo "âœ… arm64 â†’ $TAG"
          fi

          # Write formatted JSON / Ã‰crire le JSON formatÃ©
          echo "$JSON" | jq . > .last_built_tags.json
          echo "ğŸ“„ Updated tracking file:"
          cat .last_built_tags.json

      # [skip ci] prevents this commit from triggering another workflow run
      # [skip ci] empÃªche ce commit de dÃ©clencher une autre exÃ©cution du workflow
      - name: Commit
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add .last_built_tags.json
          git diff --cached --quiet && echo "Nothing to commit" && exit 0
          git commit -m "ğŸ·ï¸ Track build ${{ needs.check.outputs.latest_tag }} [skip ci]"
          git push
